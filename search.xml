<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView之ItemDecoration]]></title>
    <url>%2F2018%2F03%2F02%2FMeet-ItemDecoration%2F</url>
    <content type="text"><![CDATA[RecyclerView应该是最常使用的几个Android原生组件了，深入了解RecyclerView的使用将是提升个人技能的必经之路。 首先我们通过三张效果图来看看ItemDecoration能做什么？第一张图仅添加了基础的分割线，第二张图添加了名次效果，第三张图则将各武将按照所属国家进行了分组显示，并针对分割线进行了些许调整。 实现分割线针对第一张效果图，如果使用ListView的话，我们仅需添加以下两个属性即可实现分割线效果: 12android:divider="@android:color/darker_gray"android:dividerHeight="1dp" 可是现在ListView已经几乎被RecyclerView取代，而RecyclerView并不支持上述实现方式。那么如何在RecyclerView中实现分割线效果呢？答案是DividerItemDecoration。DividerItemDecoration是Android提供的类，专供实现分割线效果。 通过查看源代码，可以注意到DividerItemDecoration默认会去寻找listDivider属性。 1private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; 在当前theme中设置该属性： 1234567&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;item name="android:listDivider"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 如果对分割线有颜色以及高度要求，也可以自定义shape来实现： 123456789101112131415161718&lt;!-- styles.xml --&gt;&lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="android:listDivider"&gt;@drawable/defalut_divider&lt;/item&gt;&lt;/style&gt;&lt;!-- defalut_divider.xml --&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="@android:color/darker_gray"/&gt; &lt;size android:height="5dp"/&gt;&lt;/shape&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="@android:color/darker_gray"/&gt; &lt;gradient android:endColor="#00FFFF" android:startColor="#FF0000"/&gt; &lt;size android:height="2dp"/&gt;&lt;/shape&gt; 以上就是使用DividerItemDecoration配合自定义shape来画分割线的基本流程，基本能完成简单的分割线绘制要求。但如果我们需要实现一开始图三的分割线，DividerItemDecoration就无法实现了，因为它画出的分割线对于所有itemView来说是一样的，无法进行动态设定。如果是以前用ListView来实现该效果的话，通常会把不同的分割线画在item.xml里面，然后通过代码来动态判断显示哪一条： 1234567891011121314151617181920&lt;!-- item.xml --&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="56dp" android:orientation="vertical"&gt; &lt;View android:id="@+id/divider_short" android:layout_width="match_parent" android:layout_height="1dp" android:paddingStart="16dp"/&gt; &lt;View android:id="@+id/divider_long" android:layout_width="match_parent" android:layout_height="1dp" android:paddingStart="16dp"/&gt; &lt;!-- Your main content --&gt;&lt;/LinearLayout&gt; 1234567if (显示长分割线) &#123; divider_long.setVisibility(View.VISIBLE); divider_short.setVisibility(View.GONE);&#125; else &#123; divider_long.setVisibility(View.GONE); divider_short.setVisibility(View.VISIBLE);&#125; 但是通过该方式设置分割线，对代码具有较强的侵入性，UI和业务的耦合比较大，不符合通常的代码规范。也正是因为ListView在一系列的扩展与性能上都已经跟不上我们的设计要求的情况下，对RecyclerView的使用才变得越来越重要。 认识装饰器ItemDecoration字面翻译过来就是起到一个对RecyclerView每一行子布局的装饰效果。它不再满足于对简单线条的绘制，只要你会Canvas和自定义View简单使用，你就可以对Item绘制任何你想要的内容。 首先来认识一下ItemDecoration类： 1234567891011public abstract static class ItemDecoration &#123; public void onDraw(Canvas c, RecyclerView parent, State state) &#123;&#125; public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123;&#125; public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(), parent); &#125;&#125; 根据定义我们大概知道这3个方法各自具有的功能： onDraw：将内容绘制在原先itemView的下方 onDrawOver：将内容绘制在原先itemView的上方 getItemOffsets：确定每个itemView的偏移距离 首先需要来看一下getItemOffsets，确定了偏移距离，才能决定onDraw和onDrawOver的可绘制局域。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>ItemDecoration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化Android工程的资源管理]]></title>
    <url>%2F2017%2F06%2F05%2FOptimize-Android-Resources%2F</url>
    <content type="text"><![CDATA[Part 1首先，我们来看一张项目结构图， 图中标红的部分就是我们整个项目的核心部分，其中， *java*目录存放的是我们所有的源代码， *res*目录存放我们项目中需要用到的所有资源，包括布局(layout)，图片 (drawable)，字符串(strings)，动画(anim)等等…… 通常我们的项目都包括了多个模块，我们就拿微信来举例吧，首页(entrance)模块通常包含了登录(login)、注册(register)、找回密码(forgot-password)功能，进入到主页(dashboard)之后，又有四个大的功能模块，分别是微信(wechat)、通讯录(contact)、发现(discovery)、我(me)。然后在每个功能模块下又有更细化的功能模块，于是我们在定义我们的源代码结构时，我们可以建立类似这样的一个包结构： 当我们需要修改某个界面时，我们可以通过清晰的包结构快速定位到我们的源代码文件。那么对于我们的资源文件呢？ Part 2对于我们资源文件，留给我们的选择看似不多。一般而言，资源文件的结构基本如下图所示， 我们将对应的资源放入到对应的目录下即可。通常为了将资源信息与实际的功能模块挂钩，狐狸君的做法是在命名上下功夫，例如对于字符串资源，狐狸君的命名习惯是页面_关键字，例如， 同样的规则也适用于布局文件及其他资源，例如， 一个合适的前缀可以将布局文件的功能描述清楚，假如当我们需要修改登录界面的UI时，我们打开layout目录看到fragment_login就知道这就是我们要找的内容了。狐狸君的一般命名习惯是，对于Activity/Fragment文件，加上activity_/fragment_前缀，对于抽取出来的复用布局，加上view_前缀，对于ListView/RecyclerView的Item布局，就加上item_前缀。这样在寻找对应文件时，可以通过前缀快速缩小寻找的范围，找到最终的布局文件。但是，这样就是最完美的解决方案了吗？ 显然上述还不是最优方案。我们还是看上图，所有activity文件在上方，fragment文件按文件名排序依次在后面。通过这样的一个结构，我们还不能立即将fragment与它所属的activity建立一个层级关系，每一个Fragment分别是属于哪一个Activity呢？如果我们有一个朋友圈界面(fragment_moments.xml)，它属于哪一个模块，是在发现里面，还是我的里面？当我们的项目越来越庞大，功能越来越多，layout目录下的布局文件也会越来越多，全挤在这一个小小目录下，当我们需要寻找时，只能从上往下一个个浏览下来。这样的寻找效率是很低的，那怎么解决呢？我们只有一个layout目录，将布局文件放在别的地方又无法通过编译，出路在哪？ Part 3可喜的是Gradle为我们的提供了应对这种情况的解决方案。对于代码我们可以创建包结构，对于资源文件，我们也可以！！ 首先，我们需要确定我们需要创建的资源结构，根据我们的包结构，我们先创建几个对应的资源目录吧。在java和res的父目录，也就是main目录下，我们创建几个全新的目录， 可以很明显看到上图中，res目录图标右下角有一个小标志，这个标志就意味着res目录现在是作为项目的资源目录而存在的。 然后我们需要在build.gradle文件(app目录下的gradle文件，不要找项目根目录下的gradle文件)里添加几行内容， 红框内的就是我们需要添加的主要内容，如果找不到soruceSets的相关内容，请将所有内容都添加上去。还要注意的一点是，千万不要忘了红框内的最后一行内容。因为系统之前是默认将res作为资源目录的，现在我们添加了新的资源目录之后，res目录将不再被默认，如果还是有资源内容在此目录下，请一定要将此行内容添加上去。这时候我们再重新build一下项目， 可以看到我们添加的所有目录图标下都有了和res目录一样的标志。现在，所有的新添加目录都将作为资源目录而存在了。 我们可以将原先res目录下的所有目录都复制到其他目录下，再将对应资源文件放入到相应文件夹下，这样我们的项目不仅针对代码有了一个清晰包结构，针对所有的资源文件，我们也将更加容易管理与查找了，再复杂的功能模块，通过此设置方式，都是小事一桩了！！ Tips：如果我们只想要为布局文件创建结构而忽略其他的资源的话，在res目录下，我们也可以只创建几个不同的layout目录，例如layout-entrance、layout-dash，然后将布局文件放入到每个目录下的layout文件下，problem solved！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenDAO(一)：配置与简单使用]]></title>
    <url>%2F2017%2F05%2F31%2FMeet-GreenDAO%2F</url>
    <content type="text"><![CDATA[Gradle配置首先在根目录下的build.gradle下添加以下内容： 1234567891011// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.0' classpath 'org.greenrobot:greendao-gradle-plugin:3.2.2' // add plugin &#125;&#125; 第5行我没有添加项目也可以正常运行，应该是jcenter()里已经包含了相关包了吧。第9行比较重要，greenDAO是根据你定义的Entity由这个插件为你自动创建对应的数据库表文件的。 然后在app目录下build.gradle下添加一下greenDAO仓库，当然别忘了第3行的插件apply。 1234567// In your app projects build.gradle file:apply plugin: 'com.android.application'apply plugin: 'org.greenrobot.greendao' // apply plugindependencies &#123; compile 'org.greenrobot:greendao:3.2.2' // add library&#125; 到这儿，greenDAO所需要的环境就全配置完了，接下来让我来创建数据库吧！ 创建数据库Entity对象我们先创建一个Student对象吧。 12345public class Student &#123; private Long id; private String name; private int age;&#125; 在greenDAO的世界里，我们只需要创建Entity对象，greenDAO会自动帮我们创建对应的数据库表结构。在上面的代码里，我们创建了一个Student对象，有name和age两个属性，至于id这个字段，则代表了每一个Student对象在数据库表里的唯一id，默认情况下，id就是我们的主键，具有唯一性，并且默认自增。 好了，现在我们Student类有了，如何映射到数据库文件呢？ 映射到数据库表greenDAO使用注解来创建Entity对象与数据库表结构的对应关系。 @Entity：只有被@Entity注解的类才会被映射成数据库表文件。 @Id：对应表的主键，long/Long类型，默认自增。 现在我们为Student对象添加注解： 1234567@Entitypublic class Student &#123; @Id private Long id; private String name; private int age;&#125; 然后我们重新Sync一下Project，神奇的事情发生了，Student类里面自动生成了一些代码： 1234567891011121314151617181920@Entitypublic class Student &#123; @Id private Long id; private String name; private int age; @Generated(hash = 352757281) public Student(Long id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125; @Generated(hash = 1556870573) public Student() &#123; &#125; // 默默忽略Setters和Getters&#125; 就这样吗？当然不止如此，一同创建好了的还有操作Student表所需的所有相关类，默认存储在/app/build/generated/source/greendao/&lt;package-name&gt;路径下： 这里我们先不讲这里面的具体代码，先来看看数据库的增删查改(CRUD)的基本api使用吧。 创建数据库在正式进入CRUD之前还有一个小步骤——创建数据库。一般我们在操作数据库时都是先建数据库，如数据库名字，使用什么引擎，指定Unicode类型等等，然后才是建表。但是在greenDAO的使用过程中，我发现是没法先创建数据库的。可能在greenDAO看来，只有你明确建立了一组对象与表的映射关系，greenDAO才会去创建一个数据库，并创建对应的表吧。Anyway，我们刚创建了一个Student对象(表)，接下来我们需要指定我们的数据库名字。由于对数据库的操作可能持续在App的整个运行期间，我们将数据库的初始化操作放在Application里。继承Application类，加入以下代码： 1234567891011121314151617public class MyApplication extends Application &#123; private static final String DB_NAME = "db"; private DaoSession daoSession; @Override public void onCreate() &#123; super.onCreate(); DevOpenHelper helper = new DevOpenHelper(this, DB_NAME); Database db = helper.getWritableDb(); daoSession = new DaoMaster(db).newSession(); &#125; public DaoSession getDaoSession() &#123; return daoSession; &#125;&#125; DaoSession是我们操作DAO类的重要对象，主要负责提供具体的DAO类对象，在上例中，我们需要操作Student对象，需要对应的StudentDAO类提供对数据库的所有操作入口，而StudentDAO对象则由DaoSession提供。在App任意地方，当我们需要使用StudentDAO对象时，可引用以下代码： 12MyApplication app = (MyApplication) getApplication();StudentDao studentDao = app.getDaoSession().getStudentDao(); 至此，我们创建了Student的实体类，greenDAO帮我们创建了对象的数据库表，并提供了一个StudentDAO类供我们进行所有的CRUD操作。 数据库操作(CRUD)添加首先创建一个Student对象， 1234Student student = new Student();Random random = new Random();student.setName("I am " + random.nextInt(100));student.setAge(random.nextInt(100)); Note：我们不需要设置id，该字段由数据库添加成功之后返回。 12long id = dao.insert(student); // 插入到数据库当中，成功后返回主键idstudent.setId(id); 删除这里我们只看两个简单的API： 12public void delete(T entity) &#123;&#125; // 此处T对应Studentpublic void deleteByKey(K key) &#123;&#125; // 此处K对应Long 示例代码： 1234567if (adapter.getItemCount() &gt; 0) &#123; Student student = adapter.getStudents().get(0); dao.delete(student); // or dao.delete(student.getId()); adapter.getStudents().remove(0); adapter.notifyItemRemoved(0);&#125; 查询查询涉及到一个新类QueryBuilder，来看看官方说明： The QueryBuilder class lets you build custom queries for your entities without SQL and helps detect errors already at compile time. 翻译过来就是，QueryBuilder可以帮你在不用SQL语句的情况下从数据库查询数据，并且可以在编译阶段就检测到所有异常。 来看看如何使用吧。首先获取QueryBuilder对象： 1QueryBuilder&lt;Student&gt; queryBuilder = dao.queryBuilder(); 如果查询Student表里的所有数据，直接调用： 1List&lt;Student&gt; students = queryBuilder.list(); 查询条件为年龄大于等于30岁： 1List&lt;Student&gt; students = queryBuilder.where(StudentDao.Properties.Age.ge(30)).list(); 查询不同的条件时，针对哪个字段查询，就调用对应字段的Property(org.greenrobot.greendao.Property)对象，这些对象在创建数据库时greenDAO为我们都创建好了，我们只需要传入我们的查找条件，API具体可以查看Property类，这里仅列举一些： 12345eq(Object value) // 相当于SQL语句里的"="，等于notEq(Object value) // 相当于SQL语句里的"&lt;&gt;"，不等于gt(Object value) // "&gt;"ge(Object value) // "&gt;="like(String value) // 关键字查询 查询的结果按名字升序排序： 1List&lt;Student&gt; students = queryBuilder.orderAsc(StudentDao.Properties.Name).list(); 更新更新操作需要先获取到Student对象，更改信息后update： 123Student student = adapter.getStudents().get(0);student.setAge(40);dao.update(student); 以上就是CRUD的简单操作了，进阶使用后续更新。 扩展工具在结束本篇内容之前，我想介绍两个小工具，帮助大家在应用开发期间能更方便的调试我们的数据库。 StethoStetho是由Facebook提供的调试Android应用的工具。它主要有两个强大的功能，其一是获取我们的网络请求，将所有请求和响应信息显示给我们，有了它我们再也不需要每次打印一堆的Log信息了；其二便是快速访问我们的数据库。如果我们使用的是Android自带的SQLite数据库，它默认的存储路径是/data/data/&lt;package-name&gt;。如果我们需要可视化的浏览数据库，必须将db文件导出，再导出到第三方的可视化工具上方可查看。有了Stetho，我们就不需要再经历这么繁琐的步骤了。 配置Stetho只需要添加以下依赖包： 123dependencies &#123; compile 'com.facebook.stetho:stetho:1.5.0' &#125; 然后在Application里进行初始化操作： 12345@Overridepublic void onCreate() &#123; super.onCreate(); Stetho.initializeWithDefaults(this);&#125; Stetho不是单独工作的，它其实只是做到了拦截与获取所有信息，信息展示的部分还要用到我们的第二个工具。 Chrome DevTools看名字就知道了，Google出品，品质保证。 使用Chrome DevTools我们需要打开我们的Chrome浏览器，在地址栏里输入chrome://inspect，如果前面的步骤都正确执行了的话，这时候打开我们的应用，我们在Chrome里应该能看到图2的界面： 然后我们点击最底下的inspect，就会进入到该应用的主控制界面，如图3所示： 我们切换到Resources选项，然后在左侧打开Web SQL，Db_Info就是我们一开始定义的数据库的名字，STUDENT是表的名字，每当我们进行了增删查改的操作之后，点击左侧下方的更新按钮，就能实时看到我们对数据库的操作有没有成功了。 如果点击inspect之后显示空白界面，请连接一下VPN之后再重试一下，第一次加载，组件被墙所以加载不出来，以后再使用就不需要VPN的支持了。 Chrome DevTools的调试功能远不止如此，今天介绍数据库就介绍它的部分功能，大家可以自行深入探索一下哦！ 最后附上效果图： 参考与链接： greenDAO Stetho Chrome DevTools: chrome://inspect 示例代码在我的GitHub仓库里，分支是lesson1]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
        <tag>greenDAO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditText之InputFilter的使用(一)]]></title>
    <url>%2F2016%2F11%2F29%2FThe-Use-Of-InputFilter-1%2F</url>
    <content type="text"><![CDATA[引言在使用EditText的时候，我们常常需要根据需求限制用户输入的格式，字符。例如只能接收用户输入邮箱地址、电话号码、数字、密码等等。 方案第一种方法是在xml布局文件中使用android:inputType属性，见图1。常用配置: text: 对于输入没有任何限制 number: 只限于输入数字、符号以及小数点，同[0-9+-.] numberDecimal: 只允许输入数字与小数点，同[0-9.] numberSigned: 只允许输入数字与符号，同[0-9+-] textPassword: 对于输入没有限制，但会以密码的形式显示 textCapWords: 对于输入没有限制，但会将每个单词的首字母自动转换为大写 使用此方法能满足大部分的需求，且相应配置都会弹出相对应的软键盘，界面显示效果也比较和谐统一。美中不足之处在于可定制性不高，如果需要限制的格式比较特殊，无法使用该方法完成我们的需求。作为一名有素养有追求的程序员，我们不会止步于满足大多数，因此继续深入。 改进通常解决的方法是使用TextWatcher，重写以下方法。12345678@Overridepublic void beforeTextChanged(CharSequence charSequence, int start, int count, int after) &#123;&#125;@Overridepublic void onTextChanged(CharSequence charSequence, int start, int before, int count) &#123;&#125;@Overridepublic void afterTextChanged(Editable editable) &#123;&#125; 在beforeTextChanged里记住输入前的值，在onTextChanged或者afterTextChanged里拿到修改过后的值，然后与我们的需求格式(正则表达式或者String.startWith等表达式)进行比较，如果符合条件就继续输入，否则将内容显示为输入前值，并将光标定位到相应位置。 用TextWatcher基本能实现我们的预期需求了。但是，从理论上来讲，我们不应该这么用。TextWatcher，顾名思义，它是用来监听用户的输入的。当用户输入指定字符后，UI如果需要作相应更新，就可以通过TextWatcher接收到通知。除此之外，TextWatcher不应该做过多超出自己本职的工作。那么，这部分工作由谁来完成呢？？ 完善答案是InputFilter。从名字上就可以看出这是一个过滤器，负责过滤掉所有不合要求的操作。那么如何使用呢？首先看看这个类本身的结构。12345public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend);public static class AllCaps implements InputFilter &#123;&#125;public static class LengthFilter implements InputFilter &#123;&#125; 有一个待实现的filter方法，以及两个实现了filter方法的内部类。 AllCaps设置了AllCaps过滤器的EditText，会自动将用户输入的小写字母转换成大写字母，效果上与设置android:textAllCaps=&quot;true&quot;相同。使用InputFilter时需调用EditText的setFilters(InputFilter[] filters)方法。一个EditText可以设置多个过滤器，因此传入的值为数组。使用AllCaps的代码示例，1EditText.setFilters(new InputFilter[]&#123;new InputFilter.AllCaps()&#125;); LengthFilter添加该过滤器，效果上与android:maxLength=&quot;&quot;相同。使用如下，12// maxLength为自定义的具体值EditText.setFilters(new InputFilter[]&#123;new InputFilter.LengthFilter(maxLength)&#125;); filter方法我们最后再来解析，接下来我们先了解一下InputFilter的子类。 DigitsKeyListener 参考资料 android:inputType TextWatcher InputFilter]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>EditText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Mac上配置adb命令行环境]]></title>
    <url>%2F2016%2F10%2F13%2FEnable-ADB%2F</url>
    <content type="text"><![CDATA[一直没有用adb命令行的习惯，在看Training教程，然后就想敲两个命令试试，发现Mac上没有配置环境，于是就打算配置一下。 首先，打开~/.bash_profile文件，添加以下内容 export PATH=${PATH}:&lt;sdk&gt;/platform-tools 其中&lt;sdk&gt;为本地Android SDK的安装目录。 配置好好重启终端，敲入命令adb version123➜ foxivan.github.io adb versionzsh: command not found: adb➜ foxivan.github.io 没有成功，经检查是因为我配置了Oh My Zsh，所以默认调用的配置文件不是~/.bash_profile，而是~/.zshrc。调整心情，这次我们打开~/.zshrc文件，找到# User configuration条目，在下面添加需要添加的配置内容。再次打开终端，敲入命令1234➜ foxivan.github.io adb versionAndroid Debug Bridge version 1.0.36Revision e02fe72a18c3-android➜ foxivan.github.io Boom! 大工完成！ 注：由于~/.bash_profile、~/.zshrc文件都是默认隐藏的，编辑的时候可以用Vim，也可以选择先将所有隐藏的文件设置为可见，然后用文本编辑器进行编辑。设置可见/不可见的命令为12defaults write com.apple.finder AppleShowAllFiles -bool truedefaults write com.apple.finder AppleShowAllFiles -bool false]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>terminal</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试资料积累]]></title>
    <url>%2F2016%2F08%2F25%2FUnit-Test-Material%2F</url>
    <content type="text"><![CDATA[最近一直在研究单元测试，从零开始。看了很多文档，暂且把看过的觉得有用的资料存下来，供以后参考。 小创 中文，浅显易懂，适合入门 Android单元测试 (一): 首先，从是什么开始 Android单元测试 (二): 再来谈谈为什么 Android单元测试 (三): JUnit单元测试框架的使用 Android单元测试 (四): Mock以及Mockito的使用 Android单元测试 (五): 依赖注入，将mock方便的用起来 Android单元测试 (七): Robolectric，在JVM上调用安卓的类 Android单元测试 (八): Junit Rule的使用 Android单元测试 (九): 使用Mockito Annotation快速创建Mock Android单元测试 (十一): 异步代码怎么测试 Vogella 英语，介绍了简单配置与基本语法 Unit Testing with JUnit - Tutorial Unit tests with Mockito - Tutorial Mockito Latest Documentation Wiki on Github Robolectric Guide Wiki on Github Martin Flower 《重构：改善既有代码设计》作者 Mocks Aren’t Stubs]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UT</tag>
        <tag>TDD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git命令行处理多个Github账户]]></title>
    <url>%2F2016%2F07%2F02%2FGit-with-multiple-Github-Accounts-using-SSH%2F</url>
    <content type="text"><![CDATA[问题引入由于个人原因创建了另一个Github账号来托管项目，当创建好仓库之后将项目上传到Github仓库时，服务器返回以下错误：1234ERROR: Permission to user02/TestGithub.git denied to user01.fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 经过检查发现是因为我使用了SSH来克隆仓库，所以Git会默认寻找~/.ssh目录下名字为id_rsa的key，而不是我为此Github账户单独配置的名为id_rsa_jun28的key。 当前~/.ssh目录结构内容如下： id_rsaid_rsa.pubid_rsa_jun28id_rsa_jun28.pubknown_hosts 解决方法在~/.ssh目录下配置config文件，如果没有则新建一个，添加如下内容：1234567891011#第一个Github账户Host host01 HostName github.com User user01 IdentityFile ~/.ssh/id_rsa#第二个Github账户Host host02HostName github.com User user02 IdentityFile ~/.ssh/id_rsa_jun28 其中Host的内容为自定义名称，在后续操作中会用到此内容，User内容为自己的Github用户名，IdentityFile为相应Github账户使用的SSH key的文件路径。 当配置好config文件后，相应的在命令行需要更改仓库地址URL。将1git@github.com:user02/TestGithub.git 更改为1git@host02:user02/TestGithub.git 这样Git就会去匹配config文件里Host名称为host02的所对应的SSH key。最后附上Git命令行完整流程：12345678910111213141516➜ TestGithub git init Initialized empty Git repository in /Users/Ivan/Dev/workspace/TestGithub/.git/➜ TestGithub git:(master) echo "# TestGitHub" &gt;&gt; README.md➜ TestGithub git:(master) ✗ git add ./➜ TestGithub git:(master) ✗ git commit -m "First commit" [master (root-commit) cafede2] First commit 1 file changed, 1 insertion(+) create mode 100644 README.md➜ TestGithub git:(master) git remote add origin git@host02:user02/TestGithub.git➜ TestGithub git:(master) git push -u origin master Counting objects: 3, done. Writing objects: 100% (3/3), 232 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@host02:user02/TestGithub.git * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. 大功告成！！ 说明，此方法仅对采用了SSH克隆仓库的方式有效，针对Https方式本人还没有亲自测验过，如果大家有建议或者方法，欢迎指正。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
